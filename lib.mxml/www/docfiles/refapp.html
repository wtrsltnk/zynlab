<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>Mini-XML Programmers Manual, Version 2.4</TITLE>
<META NAME="author" CONTENT="Michael R. Sweet">
<META NAME="copyright" CONTENT="Copyright 2003-2007">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso-iso-8859-1">
<LINK REL="Start" HREF="index.html">
<LINK REL="Contents" HREF="index.html">
<LINK REL="Prev" HREF="relnotes.html">
<LINK REL="Next" HREF="schema.html">
<STYLE TYPE="text/css"><!--
BODY { font-family: sans-serif }
H1 { font-family: sans-serif }
H2 { font-family: sans-serif }
H3 { font-family: sans-serif }
H4 { font-family: sans-serif }
H5 { font-family: sans-serif }
H6 { font-family: sans-serif }
SUB { font-size: smaller }
SUP { font-size: smaller }
PRE { font-family: monospace }
A { text-decoration: none }
--></STYLE>
</HEAD>
<BODY>
<A HREF="index.html">Contents</A>
<A HREF="relnotes.html">Previous</A>
<A HREF="schema.html">Next</A>
<HR NOSHADE>
<H1 align="right"><A name="REFERENCE"><IMG align="right" alt="C" height="100"
hspace="10" src="C.gif" width="100"></A>Library Reference</H1>
<H2 class="title"><A NAME="8_1">Contents</A></H2>
<UL>
<LI><A href="#ENUMERATIONS">Enumerations</A></LI>
<LI><A href="#FUNCTIONS">Functions</A></LI>
<LI><A href="#STRUCTURES">Structures</A></LI>
<LI><A href="#TYPES">Types</A></LI>
<LI><A href="#UNIONS">Unions</A></LI>
</UL>

<!-- NEW PAGE -->
<H2 class="title"><A name="ENUMERATIONS">Enumerations</A></H2>
<UL>
<LI><A href="#mxml_sax_event_e"><TT>mxml_sax_event_e</TT></A></LI>
<LI><A href="#mxml_type_e"><TT>mxml_type_e</TT></A></LI>
</UL>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_sax_event_e">mxml_sax_event_e</A></H3>
<H4>Description</H4>
<P>SAX event type.</P>
<H4>Values</H4>
<DIV class="table">
<TABLE align="center" border="1" summary="Values" width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>MXML_SAX_CDATA</TT></TD><TD>CDATA node</TD></TR>
<TR><TD><TT>MXML_SAX_COMMENT</TT></TD><TD>Comment node</TD></TR>
<TR><TD><TT>MXML_SAX_DATA</TT></TD><TD>Data node</TD></TR>
<TR><TD><TT>MXML_SAX_DIRECTIVE</TT></TD><TD>Processing directive node</TD>
</TR>
<TR><TD><TT>MXML_SAX_ELEMENT_CLOSE</TT></TD><TD>Element closed</TD></TR>
<TR><TD><TT>MXML_SAX_ELEMENT_OPEN</TT></TD><TD>Element opened</TD></TR>
</TABLE>
</DIV>
<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_type_e">mxml_type_e</A></H3>
<H4>Description</H4>
<P>The XML node type.</P>
<H4>Values</H4>
<DIV class="table">
<TABLE align="center" border="1" summary="Values" width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>MXML_CUSTOM</TT>
<!--span class='info'-->
 &nbsp;Mini-XML 2.1&nbsp;</TD><TD>Custom data</TD></TR>
<TR><TD><TT>MXML_ELEMENT</TT></TD><TD>XML element with attributes</TD></TR>
<TR><TD><TT>MXML_IGNORE</TT>
<!--span class='info'-->
 &nbsp;Mini-XML 2.3&nbsp;</TD><TD>Ignore/throw away node</TD></TR>
<TR><TD><TT>MXML_INTEGER</TT></TD><TD>Integer value</TD></TR>
<TR><TD><TT>MXML_OPAQUE</TT></TD><TD>Opaque string</TD></TR>
<TR><TD><TT>MXML_REAL</TT></TD><TD>Real value</TD></TR>
<TR><TD><TT>MXML_TEXT</TT></TD><TD>Text fragment</TD></TR>
</TABLE>
</DIV>
<!-- NEW PAGE -->
<H2 class="title"><A name="FUNCTIONS">Functions</A></H2>
<UL>
<LI><A href="#mxmlAdd"><TT>mxmlAdd()</TT></A></LI>
<LI><A href="#mxmlDelete"><TT>mxmlDelete()</TT></A></LI>
<LI><A href="#mxmlElementDeleteAttr"><TT>mxmlElementDeleteAttr()</TT></A>
<!--span class='info'-->
 &nbsp;Mini-XML 2.4&nbsp;</LI>
<LI><A href="#mxmlElementGetAttr"><TT>mxmlElementGetAttr()</TT></A></LI>
<LI><A href="#mxmlElementSetAttr"><TT>mxmlElementSetAttr()</TT></A></LI>
<LI><A href="#mxmlElementSetAttrf"><TT>mxmlElementSetAttrf()</TT></A>
<!--span class='info'-->
 &nbsp;Mini-XML 2.3&nbsp;</LI>
<LI><A href="#mxmlEntityAddCallback"><TT>mxmlEntityAddCallback()</TT></A>
</LI>
<LI><A href="#mxmlEntityGetName"><TT>mxmlEntityGetName()</TT></A></LI>
<LI><A href="#mxmlEntityGetValue"><TT>mxmlEntityGetValue()</TT></A></LI>
<LI><A href="#mxmlEntityRemoveCallback"><TT>mxmlEntityRemoveCallback()</TT>
</A></LI>
<LI><A href="#mxmlFindElement"><TT>mxmlFindElement()</TT></A></LI>
<LI><A href="#mxmlIndexDelete"><TT>mxmlIndexDelete()</TT></A></LI>
<LI><A href="#mxmlIndexEnum"><TT>mxmlIndexEnum()</TT></A></LI>
<LI><A href="#mxmlIndexFind"><TT>mxmlIndexFind()</TT></A></LI>
<LI><A href="#mxmlIndexNew"><TT>mxmlIndexNew()</TT></A></LI>
<LI><A href="#mxmlIndexReset"><TT>mxmlIndexReset()</TT></A></LI>
<LI><A href="#mxmlLoadFd"><TT>mxmlLoadFd()</TT></A></LI>
<LI><A href="#mxmlLoadFile"><TT>mxmlLoadFile()</TT></A></LI>
<LI><A href="#mxmlLoadString"><TT>mxmlLoadString()</TT></A></LI>
<LI><A href="#mxmlNewCDATA"><TT>mxmlNewCDATA()</TT></A>
<!--span class='info'-->
 &nbsp;Mini-XML 2.3&nbsp;</LI>
<LI><A href="#mxmlNewCustom"><TT>mxmlNewCustom()</TT></A>
<!--span class='info'-->
 &nbsp;Mini-XML 2.1&nbsp;</LI>
<LI><A href="#mxmlNewElement"><TT>mxmlNewElement()</TT></A></LI>
<LI><A href="#mxmlNewInteger"><TT>mxmlNewInteger()</TT></A></LI>
<LI><A href="#mxmlNewOpaque"><TT>mxmlNewOpaque()</TT></A></LI>
<LI><A href="#mxmlNewReal"><TT>mxmlNewReal()</TT></A></LI>
<LI><A href="#mxmlNewText"><TT>mxmlNewText()</TT></A></LI>
<LI><A href="#mxmlNewTextf"><TT>mxmlNewTextf()</TT></A></LI>
<LI><A href="#mxmlNewXML"><TT>mxmlNewXML()</TT></A>
<!--span class='info'-->
 &nbsp;Mini-XML 2.3&nbsp;</LI>
<LI><A href="#mxmlRelease"><TT>mxmlRelease()</TT></A>
<!--span class='info'-->
 &nbsp;Mini-XML 2.3&nbsp;</LI>
<LI><A href="#mxmlRemove"><TT>mxmlRemove()</TT></A></LI>
<LI><A href="#mxmlRetain"><TT>mxmlRetain()</TT></A>
<!--span class='info'-->
 &nbsp;Mini-XML 2.3&nbsp;</LI>
<LI><A href="#mxmlSAXLoadFd"><TT>mxmlSAXLoadFd()</TT></A>
<!--span class='info'-->
 &nbsp;Mini-XML 2.3&nbsp;</LI>
<LI><A href="#mxmlSAXLoadFile"><TT>mxmlSAXLoadFile()</TT></A>
<!--span class='info'-->
 &nbsp;Mini-XML 2.3&nbsp;</LI>
<LI><A href="#mxmlSAXLoadString"><TT>mxmlSAXLoadString()</TT></A>
<!--span class='info'-->
 &nbsp;Mini-XML 2.3&nbsp;</LI>
<LI><A href="#mxmlSaveAllocString"><TT>mxmlSaveAllocString()</TT></A></LI>
<LI><A href="#mxmlSaveFd"><TT>mxmlSaveFd()</TT></A></LI>
<LI><A href="#mxmlSaveFile"><TT>mxmlSaveFile()</TT></A></LI>
<LI><A href="#mxmlSaveString"><TT>mxmlSaveString()</TT></A></LI>
<LI><A href="#mxmlSetCDATA"><TT>mxmlSetCDATA()</TT></A>
<!--span class='info'-->
 &nbsp;Mini-XML 2.3&nbsp;</LI>
<LI><A href="#mxmlSetCustom"><TT>mxmlSetCustom()</TT></A>
<!--span class='info'-->
 &nbsp;Mini-XML 2.1&nbsp;</LI>
<LI><A href="#mxmlSetCustomHandlers"><TT>mxmlSetCustomHandlers()</TT></A>
</LI>
<LI><A href="#mxmlSetElement"><TT>mxmlSetElement()</TT></A></LI>
<LI><A href="#mxmlSetErrorCallback"><TT>mxmlSetErrorCallback()</TT></A></LI>
<LI><A href="#mxmlSetInteger"><TT>mxmlSetInteger()</TT></A></LI>
<LI><A href="#mxmlSetOpaque"><TT>mxmlSetOpaque()</TT></A></LI>
<LI><A href="#mxmlSetReal"><TT>mxmlSetReal()</TT></A></LI>
<LI><A href="#mxmlSetText"><TT>mxmlSetText()</TT></A></LI>
<LI><A href="#mxmlSetTextf"><TT>mxmlSetTextf()</TT></A></LI>
<LI><A href="#mxmlSetWrapMargin"><TT>mxmlSetWrapMargin()</TT></A>
<!--span class='info'-->
 &nbsp;Mini-XML 2.3&nbsp;</LI>
<LI><A href="#mxmlWalkNext"><TT>mxmlWalkNext()</TT></A></LI>
<LI><A href="#mxmlWalkPrev"><TT>mxmlWalkPrev()</TT></A></LI>
</UL>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlAdd">mxmlAdd()</A></H3>
<H4>Description</H4>
<P>Add a node to a tree.</P>
<P>Adds the specified node to the parent. If the child argument is not
 NULL, puts the new node before or after the specified child depending
 on the value of the where argument. If the child argument is NULL, puts
 the new node at the beginning of the child list (MXML_ADD_BEFORE) or at
 the end of the child list (MXML_ADD_AFTER). The constant
 MXML_ADD_TO_PARENT can be used to specify a NULL child pointer.</P>
<H4>Syntax</H4>
<P> <TT>void
<BR> mxmlAdd( <A href="#mxml_node_t">mxml_node_t</A> * parent, int
 where, <A href="#mxml_node_t">mxml_node_t</A> * child, <A href="#mxml_node_t">
mxml_node_t</A> * node);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>parent</TT></TD><TD>Parent node</TD></TR>
<TR><TD><TT>where</TT></TD><TD>Where to add, MXML_ADD_BEFORE or
 MXML_ADD_AFTER</TD></TR>
<TR><TD><TT>child</TT></TD><TD>Child node for where or
 MXML_ADD_TO_PARENT</TD></TR>
<TR><TD><TT>node</TT></TD><TD>Node to add</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Nothing.</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlDelete">mxmlDelete()</A></H3>
<H4>Description</H4>
<P>Delete a node and all of its children.</P>
<P>If the specified node has a parent, this function first removes the
 node from its parent using the mxmlRemove() function.</P>
<H4>Syntax</H4>
<P> <TT>void
<BR> mxmlDelete( <A href="#mxml_node_t">mxml_node_t</A> * node);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Node to delete</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Nothing.</P>

<!-- NEW PAGE -->
<H3 class="title"><A NAME="8_3_3">
<!--span class='info'-->
&nbsp;Mini-XML 2.4&nbsp;<A name="mxmlElementDeleteAttr">mxmlElementDeleteAttr()</A>
</A></H3>
<H4>Description</H4>
<P>Delete an attribute.</P>
<H4>Syntax</H4>
<P> <TT>void
<BR> mxmlElementDeleteAttr( <A href="#mxml_node_t">mxml_node_t</A> *
 node, const char * name);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Element</TD></TR>
<TR><TD><TT>name</TT></TD><TD>Attribute name</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Nothing.</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlElementGetAttr">mxmlElementGetAttr()</A></H3>
<H4>Description</H4>
<P>Get an attribute.</P>
<P>This function returns NULL if the node is not an element or the named
 attribute does not exist.</P>
<H4>Syntax</H4>
<P> <TT>const char *
<BR> mxmlElementGetAttr( <A href="#mxml_node_t">mxml_node_t</A> * node,
 const char * name);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Element node</TD></TR>
<TR><TD><TT>name</TT></TD><TD>Name of attribute</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Attribute value or NULL</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlElementSetAttr">mxmlElementSetAttr()</A></H3>
<H4>Description</H4>
<P>Set an attribute.</P>
<P>If the named attribute already exists, the value of the attribute is
 replaced by the new string value. The string value is copied into the
 element node. This function does nothing if the node is not an element.</P>
<H4>Syntax</H4>
<P> <TT>void
<BR> mxmlElementSetAttr( <A href="#mxml_node_t">mxml_node_t</A> * node,
 const char * name, const char * value);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Element node</TD></TR>
<TR><TD><TT>name</TT></TD><TD>Name of attribute</TD></TR>
<TR><TD><TT>value</TT></TD><TD>Attribute value</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Nothing.</P>

<!-- NEW PAGE -->
<H3 class="title"><A NAME="8_3_6">
<!--span class='info'-->
&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlElementSetAttrf">mxmlElementSetAttrf()</A></A>
</H3>
<H4>Description</H4>
<P>Set an attribute with a formatted value.</P>
<P>If the named attribute already exists, the value of the attribute is
 replaced by the new formatted string. The formatted string value is
 copied into the element node. This function does nothing if the node is
 not an element.</P>
<H4>Syntax</H4>
<P> <TT>void
<BR> mxmlElementSetAttrf( <A href="#mxml_node_t">mxml_node_t</A> * node,
 const char * name, const char * format, ...);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Element node</TD></TR>
<TR><TD><TT>name</TT></TD><TD>Name of attribute</TD></TR>
<TR><TD><TT>format</TT></TD><TD>Printf-style attribute value</TD></TR>
<TR><TD><TT>...</TT></TD><TD>Additional arguments as needed</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Nothing.</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlEntityAddCallback">
mxmlEntityAddCallback()</A></H3>
<H4>Description</H4>
<P>Add a callback to convert entities to Unicode.</P>
<H4>Syntax</H4>
<P> <TT>int
<BR> mxmlEntityAddCallback(void);</TT></P>
<H4>Arguments</H4>
<P>None.</P>
<H4>Returns</H4>
<P>0 on success, -1 on failure</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlEntityGetName">mxmlEntityGetName()</A></H3>
<H4>Description</H4>
<P>Get the name that corresponds to the character value.</P>
<P>If val does not need to be represented by a named entity, NULL is
 returned.</P>
<H4>Syntax</H4>
<P> <TT>const char *
<BR> mxmlEntityGetName( int val);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>val</TT></TD><TD>Character value</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Entity name or NULL</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlEntityGetValue">mxmlEntityGetValue()</A></H3>
<H4>Description</H4>
<P>Get the character corresponding to a named entity.</P>
<P>The entity name can also be a numeric constant. -1 is returned if the
 name is not known.</P>
<H4>Syntax</H4>
<P> <TT>int
<BR> mxmlEntityGetValue( const char * name);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>name</TT></TD><TD>Entity name</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Character value or -1 on error</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlEntityRemoveCallback">
mxmlEntityRemoveCallback()</A></H3>
<H4>Description</H4>
<P>Remove a callback.</P>
<H4>Syntax</H4>
<P> <TT>void
<BR> mxmlEntityRemoveCallback(void);</TT></P>
<H4>Arguments</H4>
<P>None.</P>
<H4>Returns</H4>
<P>Nothing.</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlFindElement">mxmlFindElement()</A></H3>
<H4>Description</H4>
<P>Find the named element.</P>
<P>The search is constrained by the name, attribute name, and value; any
 NULL names or values are treated as wildcards, so different kinds of
 searches can be implemented by looking for all elements of a given name
 or all elements with a specific attribute. The descend argument
 determines whether the search descends into child nodes; normally you
 will use MXML_DESCEND_FIRST for the initial search and MXML_NO_DESCEND
 to find additional direct descendents of the node. The top node
 argument constrains the search to a particular node's children.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlFindElement( <A href="#mxml_node_t">mxml_node_t</A> * node, <A href="#mxml_node_t">
mxml_node_t</A> * top, const char * name, const char * attr, const char
 * value, int descend);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Current node</TD></TR>
<TR><TD><TT>top</TT></TD><TD>Top node</TD></TR>
<TR><TD><TT>name</TT></TD><TD>Element name or NULL for any</TD></TR>
<TR><TD><TT>attr</TT></TD><TD>Attribute name, or NULL for none</TD></TR>
<TR><TD><TT>value</TT></TD><TD>Attribute value, or NULL for any</TD></TR>
<TR><TD><TT>descend</TT></TD><TD>Descend into tree - MXML_DESCEND,
 MXML_NO_DESCEND, or MXML_DESCEND_FIRST</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Element node or NULL</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlIndexDelete">mxmlIndexDelete()</A></H3>
<H4>Description</H4>
<P>Delete an index.</P>
<H4>Syntax</H4>
<P> <TT>void
<BR> mxmlIndexDelete( <A href="#mxml_index_t">mxml_index_t</A> * ind);</TT>
</P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>ind</TT></TD><TD>Index to delete</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Nothing.</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlIndexEnum">mxmlIndexEnum()</A></H3>
<H4>Description</H4>
<P>Return the next node in the index.</P>
<P>Nodes are returned in the sorted order of the index.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlIndexEnum( <A href="#mxml_index_t">mxml_index_t</A> * ind);</TT>
</P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>ind</TT></TD><TD>Index to enumerate</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Next node or NULL if there is none</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlIndexFind">mxmlIndexFind()</A></H3>
<H4>Description</H4>
<P>Find the next matching node.</P>
<P>You should call mxmlIndexReset() prior to using this function for the
 first time with a particular set of &quot;element&quot; and &quot;value&quot; strings.
 Passing NULL for both &quot;element&quot; and &quot;value&quot; is equivalent to calling
 mxmlIndexEnum().</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlIndexFind( <A href="#mxml_index_t">mxml_index_t</A> * ind,
 const char * element, const char * value);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>ind</TT></TD><TD>Index to search</TD></TR>
<TR><TD><TT>element</TT></TD><TD>Element name to find, if any</TD></TR>
<TR><TD><TT>value</TT></TD><TD>Attribute value, if any</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Node or NULL if none found</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlIndexNew">mxmlIndexNew()</A></H3>
<H4>Description</H4>
<P>Create a new index.</P>
<P>The index will contain all nodes that contain the named element
 and/or attribute. If both &quot;element&quot; and &quot;attr&quot; are NULL, then the index
 will contain a sorted list of the elements in the node tree. Nodes are
 sorted by element name and optionally by attribute value if the &quot;attr&quot;
 argument is not NULL.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_index_t">mxml_index_t</A> *
<BR> mxmlIndexNew( <A href="#mxml_node_t">mxml_node_t</A> * node, const
 char * element, const char * attr);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>XML node tree</TD></TR>
<TR><TD><TT>element</TT></TD><TD>Element to index or NULL for all</TD></TR>
<TR><TD><TT>attr</TT></TD><TD>Attribute to index or NULL for none</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>New index</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlIndexReset">mxmlIndexReset()</A></H3>
<H4>Description</H4>
<P>Reset the enumeration/find pointer in the index and return the first
 node in the index.</P>
<P>This function should be called prior to using mxmlIndexEnum() or
 mxmlIndexFind() for the first time.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlIndexReset( <A href="#mxml_index_t">mxml_index_t</A> * ind);</TT>
</P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>ind</TT></TD><TD>Index to reset</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>First node or NULL if there is none</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlLoadFd">mxmlLoadFd()</A></H3>
<H4>Description</H4>
<P>Load a file descriptor into an XML node tree.</P>
<P>The nodes in the specified file are added to the specified top node.
 If no top node is provided, the XML file MUST be well-formed with a
 single parent node like &lt;?xml&gt; for the entire file. The callback
 function returns the value type that should be used for child nodes. If
 MXML_NO_CALLBACK is specified then all child nodes will be either
 MXML_ELEMENT or MXML_TEXT nodes.</P>
<P>The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
 MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
 child nodes of the specified type.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlLoadFd( <A href="#mxml_node_t">mxml_node_t</A> * top, int fd, <A
href="#mxml_load_cb_t">mxml_load_cb_t</A> cb);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>top</TT></TD><TD>Top node</TD></TR>
<TR><TD><TT>fd</TT></TD><TD>File descriptor to read from</TD></TR>
<TR><TD><TT>cb</TT></TD><TD>Callback function or MXML_NO_CALLBACK</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>First node or NULL if the file could not be read.</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlLoadFile">mxmlLoadFile()</A></H3>
<H4>Description</H4>
<P>Load a file into an XML node tree.</P>
<P>The nodes in the specified file are added to the specified top node.
 If no top node is provided, the XML file MUST be well-formed with a
 single parent node like &lt;?xml&gt; for the entire file. The callback
 function returns the value type that should be used for child nodes. If
 MXML_NO_CALLBACK is specified then all child nodes will be either
 MXML_ELEMENT or MXML_TEXT nodes.</P>
<P>The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
 MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
 child nodes of the specified type.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlLoadFile( <A href="#mxml_node_t">mxml_node_t</A> * top, FILE *
 fp, <A href="#mxml_load_cb_t">mxml_load_cb_t</A> cb);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>top</TT></TD><TD>Top node</TD></TR>
<TR><TD><TT>fp</TT></TD><TD>File to read from</TD></TR>
<TR><TD><TT>cb</TT></TD><TD>Callback function or MXML_NO_CALLBACK</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>First node or NULL if the file could not be read.</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlLoadString">mxmlLoadString()</A></H3>
<H4>Description</H4>
<P>Load a string into an XML node tree.</P>
<P>The nodes in the specified string are added to the specified top
 node. If no top node is provided, the XML string MUST be well-formed
 with a single parent node like &lt;?xml&gt; for the entire string. The
 callback function returns the value type that should be used for child
 nodes. If MXML_NO_CALLBACK is specified then all child nodes will be
 either MXML_ELEMENT or MXML_TEXT nodes.</P>
<P>The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
 MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
 child nodes of the specified type.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlLoadString( <A href="#mxml_node_t">mxml_node_t</A> * top, const
 char * s, <A href="#mxml_load_cb_t">mxml_load_cb_t</A> cb);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>top</TT></TD><TD>Top node</TD></TR>
<TR><TD><TT>s</TT></TD><TD>String to load</TD></TR>
<TR><TD><TT>cb</TT></TD><TD>Callback function or MXML_NO_CALLBACK</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>First node or NULL if the string has errors.</P>

<!-- NEW PAGE -->
<H3 class="title"><A NAME="8_3_20">
<!--span class='info'-->
&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlNewCDATA">mxmlNewCDATA()</A></A></H3>
<H4>Description</H4>
<P>Create a new CDATA node.</P>
<P>The new CDATA node is added to the end of the specified parent's
 child list. The constant MXML_NO_PARENT can be used to specify that the
 new CDATA node has no parent. The data string must be nul-terminated
 and is copied into the new node. CDATA nodes use the MXML_ELEMENT type.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlNewCDATA( <A href="#mxml_node_t">mxml_node_t</A> * parent,
 const char * data);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>parent</TT></TD><TD>Parent node or MXML_NO_PARENT</TD></TR>
<TR><TD><TT>data</TT></TD><TD>Data string</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>New node</P>

<!-- NEW PAGE -->
<H3 class="title"><A NAME="8_3_21">
<!--span class='info'-->
&nbsp;Mini-XML 2.1&nbsp;<A name="mxmlNewCustom">mxmlNewCustom()</A></A></H3>
<H4>Description</H4>
<P>Create a new custom data node.</P>
<P>The new custom node is added to the end of the specified parent's
 child list. The constant MXML_NO_PARENT can be used to specify that the
 new element node has no parent. NULL can be passed when the data in the
 node is not dynamically allocated or is separately managed.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlNewCustom( <A href="#mxml_node_t">mxml_node_t</A> * parent,
 void * data, <A href="#mxml_custom_destroy_cb_t">
mxml_custom_destroy_cb_t</A> destroy);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>parent</TT></TD><TD>Parent node or MXML_NO_PARENT</TD></TR>
<TR><TD><TT>data</TT></TD><TD>Pointer to data</TD></TR>
<TR><TD><TT>destroy</TT></TD><TD>Function to destroy data</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>New node</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlNewElement">mxmlNewElement()</A></H3>
<H4>Description</H4>
<P>Create a new element node.</P>
<P>The new element node is added to the end of the specified parent's
 child list. The constant MXML_NO_PARENT can be used to specify that the
 new element node has no parent.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlNewElement( <A href="#mxml_node_t">mxml_node_t</A> * parent,
 const char * name);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>parent</TT></TD><TD>Parent node or MXML_NO_PARENT</TD></TR>
<TR><TD><TT>name</TT></TD><TD>Name of element</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>New node</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlNewInteger">mxmlNewInteger()</A></H3>
<H4>Description</H4>
<P>Create a new integer node.</P>
<P>The new integer node is added to the end of the specified parent's
 child list. The constant MXML_NO_PARENT can be used to specify that the
 new integer node has no parent.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlNewInteger( <A href="#mxml_node_t">mxml_node_t</A> * parent,
 int integer);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>parent</TT></TD><TD>Parent node or MXML_NO_PARENT</TD></TR>
<TR><TD><TT>integer</TT></TD><TD>Integer value</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>New node</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlNewOpaque">mxmlNewOpaque()</A></H3>
<H4>Description</H4>
<P>Create a new opaque string.</P>
<P>The new opaque node is added to the end of the specified parent's
 child list. The constant MXML_NO_PARENT can be used to specify that the
 new opaque node has no parent. The opaque string must be nul-terminated
 and is copied into the new node.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlNewOpaque( <A href="#mxml_node_t">mxml_node_t</A> * parent,
 const char * opaque);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>parent</TT></TD><TD>Parent node or MXML_NO_PARENT</TD></TR>
<TR><TD><TT>opaque</TT></TD><TD>Opaque string</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>New node</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlNewReal">mxmlNewReal()</A></H3>
<H4>Description</H4>
<P>Create a new real number node.</P>
<P>The new real number node is added to the end of the specified
 parent's child list. The constant MXML_NO_PARENT can be used to specify
 that the new real number node has no parent.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlNewReal( <A href="#mxml_node_t">mxml_node_t</A> * parent,
 double real);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>parent</TT></TD><TD>Parent node or MXML_NO_PARENT</TD></TR>
<TR><TD><TT>real</TT></TD><TD>Real number value</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>New node</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlNewText">mxmlNewText()</A></H3>
<H4>Description</H4>
<P>Create a new text fragment node.</P>
<P>The new text node is added to the end of the specified parent's child
 list. The constant MXML_NO_PARENT can be used to specify that the new
 text node has no parent. The whitespace parameter is used to specify
 whether leading whitespace is present before the node. The text string
 must be nul-terminated and is copied into the new node.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlNewText( <A href="#mxml_node_t">mxml_node_t</A> * parent, int
 whitespace, const char * string);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>parent</TT></TD><TD>Parent node or MXML_NO_PARENT</TD></TR>
<TR><TD><TT>whitespace</TT></TD><TD>1 = leading whitespace, 0 = no
 whitespace</TD></TR>
<TR><TD><TT>string</TT></TD><TD>String</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>New node</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlNewTextf">mxmlNewTextf()</A></H3>
<H4>Description</H4>
<P>Create a new formatted text fragment node.</P>
<P>The new text node is added to the end of the specified parent's child
 list. The constant MXML_NO_PARENT can be used to specify that the new
 text node has no parent. The whitespace parameter is used to specify
 whether leading whitespace is present before the node. The format
 string must be nul-terminated and is formatted into the new node.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlNewTextf( <A href="#mxml_node_t">mxml_node_t</A> * parent, int
 whitespace, const char * format, ...);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>parent</TT></TD><TD>Parent node or MXML_NO_PARENT</TD></TR>
<TR><TD><TT>whitespace</TT></TD><TD>1 = leading whitespace, 0 = no
 whitespace</TD></TR>
<TR><TD><TT>format</TT></TD><TD>Printf-style frmat string</TD></TR>
<TR><TD><TT>...</TT></TD><TD>Additional args as needed</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>New node</P>

<!-- NEW PAGE -->
<H3 class="title"><A NAME="8_3_28">
<!--span class='info'-->
&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlNewXML">mxmlNewXML()</A></A></H3>
<H4>Description</H4>
<P>Create a new XML document tree.</P>
<P>The &quot;version&quot; argument specifies the version number to put in the
 ?xml element node. If NULL, version 1.0 is assumed.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlNewXML( const char * version);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>version</TT></TD><TD>Version number to use</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>New ?xml node</P>

<!-- NEW PAGE -->
<H3 class="title"><A NAME="8_3_29">
<!--span class='info'-->
&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlRelease">mxmlRelease()</A></A></H3>
<H4>Description</H4>
<P>Release a node.</P>
<P>When the reference count reaches zero, the node (and any children) is
 deleted via mxmlDelete().</P>
<H4>Syntax</H4>
<P> <TT>int
<BR> mxmlRelease( <A href="#mxml_node_t">mxml_node_t</A> * node);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Node</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>New reference count</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlRemove">mxmlRemove()</A></H3>
<H4>Description</H4>
<P>Remove a node from its parent.</P>
<P>Does not free memory used by the node - use mxmlDelete() for that.
 This function does nothing if the node has no parent.</P>
<H4>Syntax</H4>
<P> <TT>void
<BR> mxmlRemove( <A href="#mxml_node_t">mxml_node_t</A> * node);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Node to remove</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Nothing.</P>

<!-- NEW PAGE -->
<H3 class="title"><A NAME="8_3_31">
<!--span class='info'-->
&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlRetain">mxmlRetain()</A></A></H3>
<H4>Description</H4>
<P>Retain a node.</P>
<H4>Syntax</H4>
<P> <TT>int
<BR> mxmlRetain( <A href="#mxml_node_t">mxml_node_t</A> * node);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Node</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>New reference count</P>

<!-- NEW PAGE -->
<H3 class="title"><A NAME="8_3_32">
<!--span class='info'-->
&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlSAXLoadFd">mxmlSAXLoadFd()</A></A></H3>
<H4>Description</H4>
<P>Load a file descriptor into an XML node tree using a SAX callback.</P>
<P>The nodes in the specified file are added to the specified top node.
 If no top node is provided, the XML file MUST be well-formed with a
 single parent node like &lt;?xml&gt; for the entire file. The callback
 function returns the value type that should be used for child nodes. If
 MXML_NO_CALLBACK is specified then all child nodes will be either
 MXML_ELEMENT or MXML_TEXT nodes.</P>
<P>The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
 MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
 child nodes of the specified type.</P>
<P>The SAX callback must call mxmlRetain() for any nodes that need to be
 kept for later use. Otherwise, nodes are deleted when the parent node
 is closed or after each data, comment, CDATA, or directive node.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlSAXLoadFd( <A href="#mxml_node_t">mxml_node_t</A> * top, int
 fd, <A href="#mxml_load_cb_t">mxml_load_cb_t</A> cb, <A href="#mxml_sax_cb_t">
mxml_sax_cb_t</A> sax_cb, void * sax_data);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>top</TT></TD><TD>Top node</TD></TR>
<TR><TD><TT>fd</TT></TD><TD>File descriptor to read from</TD></TR>
<TR><TD><TT>cb</TT></TD><TD>Callback function or MXML_NO_CALLBACK</TD></TR>
<TR><TD><TT>sax_cb</TT></TD><TD>SAX callback or MXML_NO_CALLBACK</TD></TR>
<TR><TD><TT>sax_data</TT></TD><TD>SAX user data</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>First node or NULL if the file could not be read.</P>

<!-- NEW PAGE -->
<H3 class="title"><A NAME="8_3_33">
<!--span class='info'-->
&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlSAXLoadFile">mxmlSAXLoadFile()</A></A></H3>
<H4>Description</H4>
<P>Load a file into an XML node tree using a SAX callback.</P>
<P>The nodes in the specified file are added to the specified top node.
 If no top node is provided, the XML file MUST be well-formed with a
 single parent node like &lt;?xml&gt; for the entire file. The callback
 function returns the value type that should be used for child nodes. If
 MXML_NO_CALLBACK is specified then all child nodes will be either
 MXML_ELEMENT or MXML_TEXT nodes.</P>
<P>The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
 MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
 child nodes of the specified type.</P>
<P>The SAX callback must call mxmlRetain() for any nodes that need to be
 kept for later use. Otherwise, nodes are deleted when the parent node
 is closed or after each data, comment, CDATA, or directive node.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlSAXLoadFile( <A href="#mxml_node_t">mxml_node_t</A> * top, FILE
 * fp, <A href="#mxml_load_cb_t">mxml_load_cb_t</A> cb, <A href="#mxml_sax_cb_t">
mxml_sax_cb_t</A> sax_cb, void * sax_data);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>top</TT></TD><TD>Top node</TD></TR>
<TR><TD><TT>fp</TT></TD><TD>File to read from</TD></TR>
<TR><TD><TT>cb</TT></TD><TD>Callback function or MXML_NO_CALLBACK</TD></TR>
<TR><TD><TT>sax_cb</TT></TD><TD>SAX callback or MXML_NO_CALLBACK</TD></TR>
<TR><TD><TT>sax_data</TT></TD><TD>SAX user data</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>First node or NULL if the file could not be read.</P>

<!-- NEW PAGE -->
<H3 class="title"><A NAME="8_3_34">
<!--span class='info'-->
&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlSAXLoadString">mxmlSAXLoadString()</A></A></H3>
<H4>Description</H4>
<P>Load a string into an XML node tree using a SAX callback.</P>
<P>The nodes in the specified string are added to the specified top
 node. If no top node is provided, the XML string MUST be well-formed
 with a single parent node like &lt;?xml&gt; for the entire string. The
 callback function returns the value type that should be used for child
 nodes. If MXML_NO_CALLBACK is specified then all child nodes will be
 either MXML_ELEMENT or MXML_TEXT nodes.</P>
<P>The constants MXML_INTEGER_CALLBACK, MXML_OPAQUE_CALLBACK,
 MXML_REAL_CALLBACK, and MXML_TEXT_CALLBACK are defined for loading
 child nodes of the specified type.</P>
<P>The SAX callback must call mxmlRetain() for any nodes that need to be
 kept for later use. Otherwise, nodes are deleted when the parent node
 is closed or after each data, comment, CDATA, or directive node.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlSAXLoadString( <A href="#mxml_node_t">mxml_node_t</A> * top,
 const char * s, <A href="#mxml_load_cb_t">mxml_load_cb_t</A> cb, <A href="#mxml_sax_cb_t">
mxml_sax_cb_t</A> sax_cb, void * sax_data);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>top</TT></TD><TD>Top node</TD></TR>
<TR><TD><TT>s</TT></TD><TD>String to load</TD></TR>
<TR><TD><TT>cb</TT></TD><TD>Callback function or MXML_NO_CALLBACK</TD></TR>
<TR><TD><TT>sax_cb</TT></TD><TD>SAX callback or MXML_NO_CALLBACK</TD></TR>
<TR><TD><TT>sax_data</TT></TD><TD>SAX user data</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>First node or NULL if the string has errors.</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlSaveAllocString">mxmlSaveAllocString()</A>
</H3>
<H4>Description</H4>
<P>Save an XML node tree to an allocated string.</P>
<P>This function returns a pointer to a string containing the textual
 representation of the XML node tree. The string should be freed using
 the free() function when you are done with it. NULL is returned if the
 node would produce an empty string or if the string cannot be
 allocated.</P>
<P>The callback argument specifies a function that returns a whitespace
 string or NULL before and after each element. If MXML_NO_CALLBACK is
 specified, whitespace will only be added before MXML_TEXT nodes with
 leading whitespace and before attribute names inside opening element
 tags.</P>
<H4>Syntax</H4>
<P> <TT>char *
<BR> mxmlSaveAllocString( <A href="#mxml_node_t">mxml_node_t</A> * node,
 <A href="#mxml_save_cb_t">mxml_save_cb_t</A> cb);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Node to write</TD></TR>
<TR><TD><TT>cb</TT></TD><TD>Whitespace callback or MXML_NO_CALLBACK</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Allocated string or NULL</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlSaveFd">mxmlSaveFd()</A></H3>
<H4>Description</H4>
<P>Save an XML tree to a file descriptor.</P>
<P>The callback argument specifies a function that returns a whitespace
 string or NULL before and after each element. If MXML_NO_CALLBACK is
 specified, whitespace will only be added before MXML_TEXT nodes with
 leading whitespace and before attribute names inside opening element
 tags.</P>
<H4>Syntax</H4>
<P> <TT>int
<BR> mxmlSaveFd( <A href="#mxml_node_t">mxml_node_t</A> * node, int fd, <A
href="#mxml_save_cb_t">mxml_save_cb_t</A> cb);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Node to write</TD></TR>
<TR><TD><TT>fd</TT></TD><TD>File descriptor to write to</TD></TR>
<TR><TD><TT>cb</TT></TD><TD>Whitespace callback or MXML_NO_CALLBACK</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>0 on success, -1 on error.</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlSaveFile">mxmlSaveFile()</A></H3>
<H4>Description</H4>
<P>Save an XML tree to a file.</P>
<P>The callback argument specifies a function that returns a whitespace
 string or NULL before and after each element. If MXML_NO_CALLBACK is
 specified, whitespace will only be added before MXML_TEXT nodes with
 leading whitespace and before attribute names inside opening element
 tags.</P>
<H4>Syntax</H4>
<P> <TT>int
<BR> mxmlSaveFile( <A href="#mxml_node_t">mxml_node_t</A> * node, FILE *
 fp, <A href="#mxml_save_cb_t">mxml_save_cb_t</A> cb);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Node to write</TD></TR>
<TR><TD><TT>fp</TT></TD><TD>File to write to</TD></TR>
<TR><TD><TT>cb</TT></TD><TD>Whitespace callback or MXML_NO_CALLBACK</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>0 on success, -1 on error.</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlSaveString">mxmlSaveString()</A></H3>
<H4>Description</H4>
<P>Save an XML node tree to a string.</P>
<P>This function returns the total number of bytes that would be
 required for the string but only copies (bufsize - 1) characters into
 the specified buffer.</P>
<P>The callback argument specifies a function that returns a whitespace
 string or NULL before and after each element. If MXML_NO_CALLBACK is
 specified, whitespace will only be added before MXML_TEXT nodes with
 leading whitespace and before attribute names inside opening element
 tags.</P>
<H4>Syntax</H4>
<P> <TT>int
<BR> mxmlSaveString( <A href="#mxml_node_t">mxml_node_t</A> * node, char
 * buffer, int bufsize, <A href="#mxml_save_cb_t">mxml_save_cb_t</A>
 cb);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Node to write</TD></TR>
<TR><TD><TT>buffer</TT></TD><TD>String buffer</TD></TR>
<TR><TD><TT>bufsize</TT></TD><TD>Size of string buffer</TD></TR>
<TR><TD><TT>cb</TT></TD><TD>Whitespace callback or MXML_NO_CALLBACK</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Size of string</P>

<!-- NEW PAGE -->
<H3 class="title"><A NAME="8_3_39">
<!--span class='info'-->
&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlSetCDATA">mxmlSetCDATA()</A></A></H3>
<H4>Description</H4>
<P>Set the element name of a CDATA node.</P>
<P>The node is not changed if it is not a CDATA element node.</P>
<H4>Syntax</H4>
<P> <TT>int
<BR> mxmlSetCDATA( <A href="#mxml_node_t">mxml_node_t</A> * node, const
 char * data);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Node to set</TD></TR>
<TR><TD><TT>data</TT></TD><TD>New data string</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>0 on success, -1 on failure</P>

<!-- NEW PAGE -->
<H3 class="title"><A NAME="8_3_40">
<!--span class='info'-->
&nbsp;Mini-XML 2.1&nbsp;<A name="mxmlSetCustom">mxmlSetCustom()</A></A></H3>
<H4>Description</H4>
<P>Set the data and destructor of a custom data node.</P>
<P>The node is not changed if it is not a custom node.</P>
<H4>Syntax</H4>
<P> <TT>int
<BR> mxmlSetCustom( <A href="#mxml_node_t">mxml_node_t</A> * node, void
 * data, <A href="#mxml_custom_destroy_cb_t">mxml_custom_destroy_cb_t</A>
 destroy);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Node to set</TD></TR>
<TR><TD><TT>data</TT></TD><TD>New data pointer</TD></TR>
<TR><TD><TT>destroy</TT></TD><TD>New destructor function</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>0 on success, -1 on failure</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlSetCustomHandlers">
mxmlSetCustomHandlers()</A></H3>
<H4>Description</H4>
<P>Set the handling functions for custom data.</P>
<P>The load function accepts a node pointer and a data string and must
 return 0 on success and non-zero on error.</P>
<P>The save function accepts a node pointer and must return a malloc'd
 string on success and NULL on error.</P>
<H4>Syntax</H4>
<P> <TT>void
<BR> mxmlSetCustomHandlers( <A href="#mxml_custom_load_cb_t">
mxml_custom_load_cb_t</A> load, <A href="#mxml_custom_save_cb_t">
mxml_custom_save_cb_t</A> save);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>load</TT></TD><TD>Load function</TD></TR>
<TR><TD><TT>save</TT></TD><TD>Save function</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Nothing.</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlSetElement">mxmlSetElement()</A></H3>
<H4>Description</H4>
<P>Set the name of an element node.</P>
<P>The node is not changed if it is not an element node.</P>
<H4>Syntax</H4>
<P> <TT>int
<BR> mxmlSetElement( <A href="#mxml_node_t">mxml_node_t</A> * node,
 const char * name);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Node to set</TD></TR>
<TR><TD><TT>name</TT></TD><TD>New name string</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>0 on success, -1 on failure</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlSetErrorCallback">mxmlSetErrorCallback()</A>
</H3>
<H4>Description</H4>
<P>Set the error message callback.</P>
<H4>Syntax</H4>
<P> <TT>void
<BR> mxmlSetErrorCallback( <A href="#mxml_error_cb_t">mxml_error_cb_t</A>
 cb);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>cb</TT></TD><TD>Error callback function</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Nothing.</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlSetInteger">mxmlSetInteger()</A></H3>
<H4>Description</H4>
<P>Set the value of an integer node.</P>
<P>The node is not changed if it is not an integer node.</P>
<H4>Syntax</H4>
<P> <TT>int
<BR> mxmlSetInteger( <A href="#mxml_node_t">mxml_node_t</A> * node, int
 integer);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Node to set</TD></TR>
<TR><TD><TT>integer</TT></TD><TD>Integer value</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>0 on success, -1 on failure</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlSetOpaque">mxmlSetOpaque()</A></H3>
<H4>Description</H4>
<P>Set the value of an opaque node.</P>
<P>The node is not changed if it is not an opaque node.</P>
<H4>Syntax</H4>
<P> <TT>int
<BR> mxmlSetOpaque( <A href="#mxml_node_t">mxml_node_t</A> * node, const
 char * opaque);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Node to set</TD></TR>
<TR><TD><TT>opaque</TT></TD><TD>Opaque string</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>0 on success, -1 on failure</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlSetReal">mxmlSetReal()</A></H3>
<H4>Description</H4>
<P>Set the value of a real number node.</P>
<P>The node is not changed if it is not a real number node.</P>
<H4>Syntax</H4>
<P> <TT>int
<BR> mxmlSetReal( <A href="#mxml_node_t">mxml_node_t</A> * node, double
 real);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Node to set</TD></TR>
<TR><TD><TT>real</TT></TD><TD>Real number value</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>0 on success, -1 on failure</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlSetText">mxmlSetText()</A></H3>
<H4>Description</H4>
<P>Set the value of a text node.</P>
<P>The node is not changed if it is not a text node.</P>
<H4>Syntax</H4>
<P> <TT>int
<BR> mxmlSetText( <A href="#mxml_node_t">mxml_node_t</A> * node, int
 whitespace, const char * string);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Node to set</TD></TR>
<TR><TD><TT>whitespace</TT></TD><TD>1 = leading whitespace, 0 = no
 whitespace</TD></TR>
<TR><TD><TT>string</TT></TD><TD>String</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>0 on success, -1 on failure</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlSetTextf">mxmlSetTextf()</A></H3>
<H4>Description</H4>
<P>Set the value of a text node to a formatted string.</P>
<P>The node is not changed if it is not a text node.</P>
<H4>Syntax</H4>
<P> <TT>int
<BR> mxmlSetTextf( <A href="#mxml_node_t">mxml_node_t</A> * node, int
 whitespace, const char * format, ...);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Node to set</TD></TR>
<TR><TD><TT>whitespace</TT></TD><TD>1 = leading whitespace, 0 = no
 whitespace</TD></TR>
<TR><TD><TT>format</TT></TD><TD>Printf-style format string</TD></TR>
<TR><TD><TT>...</TT></TD><TD>Additional arguments as needed</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>0 on success, -1 on failure</P>

<!-- NEW PAGE -->
<H3 class="title"><A NAME="8_3_49">
<!--span class='info'-->
&nbsp;Mini-XML 2.3&nbsp;<A name="mxmlSetWrapMargin">mxmlSetWrapMargin()</A></A></H3>
<H4>Description</H4>
<P>Set the the wrap margin when saving XML data.</P>
<P>Wrapping is disabled when &quot;column&quot; is &lt;= 0.</P>
<H4>Syntax</H4>
<P> <TT>void
<BR> mxmlSetWrapMargin( int column);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>column</TT></TD><TD>Column for wrapping</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Nothing.</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlWalkNext">mxmlWalkNext()</A></H3>
<H4>Description</H4>
<P>Walk to the next logical node in the tree.</P>
<P>The descend argument controls whether the first child is considered
 to be the next node. The top node argument constrains the walk to the
 node's children.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlWalkNext( <A href="#mxml_node_t">mxml_node_t</A> * node, <A href="#mxml_node_t">
mxml_node_t</A> * top, int descend);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Current node</TD></TR>
<TR><TD><TT>top</TT></TD><TD>Top node</TD></TR>
<TR><TD><TT>descend</TT></TD><TD>Descend into tree - MXML_DESCEND,
 MXML_NO_DESCEND, or MXML_DESCEND_FIRST</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Next node or NULL</P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxmlWalkPrev">mxmlWalkPrev()</A></H3>
<H4>Description</H4>
<P>Walk to the previous logical node in the tree.</P>
<P>The descend argument controls whether the previous node's last child
 is considered to be the previous node. The top node argument constrains
 the walk to the node's children.</P>
<H4>Syntax</H4>
<P> <TT><A href="#mxml_node_t">mxml_node_t</A> *
<BR> mxmlWalkPrev( <A href="#mxml_node_t">mxml_node_t</A> * node, <A href="#mxml_node_t">
mxml_node_t</A> * top, int descend);</TT></P>
<H4>Arguments</H4>
<DIV class="table">
<TABLE align="center" border="1" cellpadding="5" cellspacing="0" summary="Arguments"
width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>node</TT></TD><TD>Current node</TD></TR>
<TR><TD><TT>top</TT></TD><TD>Top node</TD></TR>
<TR><TD><TT>descend</TT></TD><TD>Descend into tree - MXML_DESCEND,
 MXML_NO_DESCEND, or MXML_DESCEND_FIRST</TD></TR>
</TABLE>
</DIV>
<H4>Returns</H4>
<P>Previous node or NULL</P>

<!-- NEW PAGE -->
<H2 class="title"><A name="STRUCTURES">Structures</A></H2>
<UL>
<LI><A href="#mxml_attr_s"><TT>mxml_attr_s</TT></A></LI>
<LI><A href="#mxml_custom_s"><TT>mxml_custom_s</TT></A>
<!--span class='info'-->
 &nbsp;Mini-XML 2.1&nbsp;</LI>
<LI><A href="#mxml_element_s"><TT>mxml_element_s</TT></A></LI>
<LI><A href="#mxml_index_s"><TT>mxml_index_s</TT></A></LI>
<LI><A href="#mxml_node_s"><TT>mxml_node_s</TT></A></LI>
<LI><A href="#mxml_text_s"><TT>mxml_text_s</TT></A></LI>
</UL>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_attr_s">mxml_attr_s</A></H3>
<H4>Description</H4>
<P>An XML element attribute value.</P>
<H4>Definition</H4>
<P> <TT>struct mxml_attr_s
<BR> {
<BR> &nbsp;&nbsp;char * name;
<BR> &nbsp;&nbsp;char * value;
<BR> };</TT></P>
<H4>Members</H4>
<DIV class="table">
<TABLE align="center" border="1" summary="Members" width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>name</TT></TD><TD>Attribute name</TD></TR>
<TR><TD><TT>value</TT></TD><TD>Attribute value</TD></TR>
</TABLE>
</DIV>
<!-- NEW PAGE -->
<H3 class="title"><A NAME="8_4_2">
<!--span class='info'-->
&nbsp;Mini-XML 2.1&nbsp;<A name="mxml_custom_s">mxml_custom_s</A></A></H3>
<H4>Description</H4>
<P>An XML custom value.</P>
<H4>Definition</H4>
<P> <TT>struct mxml_custom_s
<BR> {
<BR> &nbsp;&nbsp;void * data;
<BR> &nbsp;&nbsp;<A href="#mxml_custom_destroy_cb_t">mxml_custom_destroy_cb_t</A>
 destroy;
<BR> };</TT></P>
<H4>Members</H4>
<DIV class="table">
<TABLE align="center" border="1" summary="Members" width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>data</TT></TD><TD>Pointer to (allocated) custom data</TD></TR>
<TR><TD><TT>destroy</TT></TD><TD>Pointer to destructor function</TD></TR>
</TABLE>
</DIV>
<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_element_s">mxml_element_s</A></H3>
<H4>Description</H4>
<P>An XML element value.</P>
<H4>Definition</H4>
<P> <TT>struct mxml_element_s
<BR> {
<BR> &nbsp;&nbsp;<A href="#mxml_attr_t">mxml_attr_t</A> * attrs;
<BR> &nbsp;&nbsp;char * name;
<BR> &nbsp;&nbsp;int num_attrs;
<BR> };</TT></P>
<H4>Members</H4>
<DIV class="table">
<TABLE align="center" border="1" summary="Members" width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>attrs</TT></TD><TD>Attributes</TD></TR>
<TR><TD><TT>name</TT></TD><TD>Name of element</TD></TR>
<TR><TD><TT>num_attrs</TT></TD><TD>Number of attributes</TD></TR>
</TABLE>
</DIV>
<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_index_s">mxml_index_s</A></H3>
<H4>Description</H4>
<P>An XML node index.</P>
<H4>Definition</H4>
<P> <TT>struct mxml_index_s
<BR> {
<BR> &nbsp;&nbsp;int alloc_nodes;
<BR> &nbsp;&nbsp;char * attr;
<BR> &nbsp;&nbsp;int cur_node;
<BR> &nbsp;&nbsp;<A href="#mxml_node_t">mxml_node_t</A> ** nodes;
<BR> &nbsp;&nbsp;int num_nodes;
<BR> };</TT></P>
<H4>Members</H4>
<DIV class="table">
<TABLE align="center" border="1" summary="Members" width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>alloc_nodes</TT></TD><TD>Allocated nodes in index</TD></TR>
<TR><TD><TT>attr</TT></TD><TD>Attribute used for indexing or NULL</TD></TR>
<TR><TD><TT>cur_node</TT></TD><TD>Current node</TD></TR>
<TR><TD><TT>nodes</TT></TD><TD>Node array</TD></TR>
<TR><TD><TT>num_nodes</TT></TD><TD>Number of nodes in index</TD></TR>
</TABLE>
</DIV>
<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_node_s">mxml_node_s</A></H3>
<H4>Description</H4>
<P>An XML node.</P>
<H4>Definition</H4>
<P> <TT>struct mxml_node_s
<BR> {
<BR> &nbsp;&nbsp;struct <A href="#mxml_node_s">mxml_node_s</A> * child;
<BR> &nbsp;&nbsp;struct <A href="#mxml_node_s">mxml_node_s</A> * last_child;
<BR> &nbsp;&nbsp;struct <A href="#mxml_node_s">mxml_node_s</A> * next;
<BR> &nbsp;&nbsp;struct <A href="#mxml_node_s">mxml_node_s</A> * parent;
<BR> &nbsp;&nbsp;struct <A href="#mxml_node_s">mxml_node_s</A> * prev;
<BR> &nbsp;&nbsp;int ref_count;
<BR> &nbsp;&nbsp;mxml_type_t type;
<BR> &nbsp;&nbsp;void * user_data;
<BR> &nbsp;&nbsp;<A href="#mxml_value_t">mxml_value_t</A> value;
<BR> };</TT></P>
<H4>Members</H4>
<DIV class="table">
<TABLE align="center" border="1" summary="Members" width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>child</TT></TD><TD>First child node</TD></TR>
<TR><TD><TT>last_child</TT></TD><TD>Last child node</TD></TR>
<TR><TD><TT>next</TT></TD><TD>Next node under same parent</TD></TR>
<TR><TD><TT>parent</TT></TD><TD>Parent node</TD></TR>
<TR><TD><TT>prev</TT></TD><TD>Previous node under same parent</TD></TR>
<TR><TD><TT>ref_count</TT></TD><TD>Use count</TD></TR>
<TR><TD><TT>type</TT></TD><TD>Node type</TD></TR>
<TR><TD><TT>user_data</TT></TD><TD>User data</TD></TR>
<TR><TD><TT>value</TT></TD><TD>Node value</TD></TR>
</TABLE>
</DIV>
<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_text_s">mxml_text_s</A></H3>
<H4>Description</H4>
<P>An XML text value.</P>
<H4>Definition</H4>
<P> <TT>struct mxml_text_s
<BR> {
<BR> &nbsp;&nbsp;char * string;
<BR> &nbsp;&nbsp;int whitespace;
<BR> };</TT></P>
<H4>Members</H4>
<DIV class="table">
<TABLE align="center" border="1" summary="Members" width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>string</TT></TD><TD>Fragment string</TD></TR>
<TR><TD><TT>whitespace</TT></TD><TD>Leading whitespace?</TD></TR>
</TABLE>
</DIV>
<!-- NEW PAGE -->
<H2 class="title"><A name="TYPES">Types</A></H2>
<UL>
<LI><A href="#mxml_attr_t"><TT>mxml_attr_t</TT></A></LI>
<LI><A href="#mxml_custom_destroy_cb_t"><TT>mxml_custom_destroy_cb_t</TT>
</A></LI>
<LI><A href="#mxml_custom_load_cb_t"><TT>mxml_custom_load_cb_t</TT></A></LI>
<LI><A href="#mxml_custom_save_cb_t"><TT>mxml_custom_save_cb_t</TT></A></LI>
<LI><A href="#mxml_custom_t"><TT>mxml_custom_t</TT></A>
<!--span class='info'-->
 &nbsp;Mini-XML 2.1&nbsp;</LI>
<LI><A href="#mxml_element_t"><TT>mxml_element_t</TT></A></LI>
<LI><A href="#mxml_error_cb_t"><TT>mxml_error_cb_t</TT></A></LI>
<LI><A href="#mxml_index_t"><TT>mxml_index_t</TT></A></LI>
<LI><A href="#mxml_load_cb_t"><TT>mxml_load_cb_t</TT></A></LI>
<LI><A href="#mxml_node_t"><TT>mxml_node_t</TT></A></LI>
<LI><A href="#mxml_save_cb_t"><TT>mxml_save_cb_t</TT></A></LI>
<LI><A href="#mxml_sax_cb_t"><TT>mxml_sax_cb_t</TT></A></LI>
<LI><A href="#mxml_sax_event_t"><TT>mxml_sax_event_t</TT></A></LI>
<LI><A href="#mxml_text_t"><TT>mxml_text_t</TT></A></LI>
<LI><A href="#mxml_value_t"><TT>mxml_value_t</TT></A></LI>
</UL>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_attr_t">mxml_attr_t</A></H3>
<H4>Description</H4>
<P>An XML element attribute value.</P>
<H4>Definition</H4>
<P> <TT>typedef struct <A href="#mxml_attr_s">mxml_attr_s</A>
 mxml_attr_t;</TT></P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_custom_destroy_cb_t">
mxml_custom_destroy_cb_t</A></H3>
<H4>Description</H4>
<P>Custom data destructor</P>
<H4>Definition</H4>
<P> <TT>typedef void (*mxml_custom_destroy_cb_t)(void *);</TT></P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_custom_load_cb_t">mxml_custom_load_cb_t</A>
</H3>
<H4>Description</H4>
<P>Custom data load callback function</P>
<H4>Definition</H4>
<P> <TT>typedef int (*mxml_custom_load_cb_t)(<A href="#mxml_node_t">
mxml_node_t</A> *, const char *);</TT></P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_custom_save_cb_t">mxml_custom_save_cb_t</A>
</H3>
<H4>Description</H4>
<P>Custom data save callback function</P>
<H4>Definition</H4>
<P> <TT>typedef char * (*mxml_custom_save_cb_t)(<A href="#mxml_node_t">
mxml_node_t</A> *);</TT></P>

<!-- NEW PAGE -->
<H3 class="title"><A NAME="8_5_5">
<!--span class='info'-->
&nbsp;Mini-XML 2.1&nbsp;<A name="mxml_custom_t">mxml_custom_t</A></A></H3>
<H4>Description</H4>
<P>An XML custom value.</P>
<H4>Definition</H4>
<P> <TT>typedef struct <A href="#mxml_custom_s">mxml_custom_s</A>
 mxml_custom_t;</TT></P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_element_t">mxml_element_t</A></H3>
<H4>Description</H4>
<P>An XML element value.</P>
<H4>Definition</H4>
<P> <TT>typedef struct <A href="#mxml_element_s">mxml_element_s</A>
 mxml_element_t;</TT></P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_error_cb_t">mxml_error_cb_t</A></H3>
<H4>Description</H4>
<P>Error callback function</P>
<H4>Definition</H4>
<P> <TT>typedef void (*mxml_error_cb_t)(const char *);</TT></P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_index_t">mxml_index_t</A></H3>
<H4>Description</H4>
<P>An XML node index.</P>
<H4>Definition</H4>
<P> <TT>typedef struct <A href="#mxml_index_s">mxml_index_s</A>
 mxml_index_t;</TT></P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_load_cb_t">mxml_load_cb_t</A></H3>
<H4>Description</H4>
<P>Load callback function</P>
<H4>Definition</H4>
<P> <TT>typedef mxml_type_t (*mxml_load_cb_t)(<A href="#mxml_node_t">
mxml_node_t</A> *);</TT></P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_node_t">mxml_node_t</A></H3>
<H4>Description</H4>
<P>An XML node.</P>
<H4>Definition</H4>
<P> <TT>typedef struct <A href="#mxml_node_s">mxml_node_s</A>
 mxml_node_t;</TT></P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_save_cb_t">mxml_save_cb_t</A></H3>
<H4>Description</H4>
<P>Save callback function</P>
<H4>Definition</H4>
<P> <TT>typedef const char * (*mxml_save_cb_t)(<A href="#mxml_node_t">
mxml_node_t</A> *, int);</TT></P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_sax_cb_t">mxml_sax_cb_t</A></H3>
<H4>Description</H4>
<P>SAX callback function</P>
<H4>Definition</H4>
<P> <TT>typedef void (*mxml_sax_cb_t)(<A href="#mxml_node_t">mxml_node_t</A>
 *, mxml_sax_event_t, void *);</TT></P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_sax_event_t">mxml_sax_event_t</A></H3>
<H4>Description</H4>
<P>SAX event type.</P>
<H4>Definition</H4>
<P> <TT>typedef enum <A href="#mxml_sax_event_e">mxml_sax_event_e</A>
 mxml_sax_event_t;</TT></P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_text_t">mxml_text_t</A></H3>
<H4>Description</H4>
<P>An XML text value.</P>
<H4>Definition</H4>
<P> <TT>typedef struct <A href="#mxml_text_s">mxml_text_s</A>
 mxml_text_t;</TT></P>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_value_t">mxml_value_t</A></H3>
<H4>Description</H4>
<P>An XML node value.</P>
<H4>Definition</H4>
<P> <TT>typedef union <A href="#mxml_value_u">mxml_value_u</A>
 mxml_value_t;</TT></P>

<!-- NEW PAGE -->
<H2 class="title"><A name="UNIONS">Unions</A></H2>
<UL>
<LI><A href="#mxml_value_u"><TT>mxml_value_u</TT></A></LI>
</UL>

<!-- NEW PAGE -->
<H3 class="title"><A name="mxml_value_u">mxml_value_u</A></H3>
<H4>Description</H4>
<P>An XML node value.</P>
<H4>Definition</H4>
<P> <TT>union mxml_value_u
<BR> {
<BR> &nbsp;&nbsp;<A href="#mxml_custom_t">mxml_custom_t</A> custom;
<BR> &nbsp;&nbsp;<A href="#mxml_element_t">mxml_element_t</A> element;
<BR> &nbsp;&nbsp;int integer;
<BR> &nbsp;&nbsp;char * opaque;
<BR> &nbsp;&nbsp;double real;
<BR> &nbsp;&nbsp;<A href="#mxml_text_t">mxml_text_t</A> text;
<BR> };</TT></P>
<H4>Members</H4>
<DIV class="table">
<TABLE align="center" border="1" summary="Members" width="80%"><THEAD></THEAD>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TBODY></TBODY>
<TR><TD><TT>custom</TT>
<!--span class='info'-->
 &nbsp;Mini-XML 2.1&nbsp;</TD><TD>Custom data</TD></TR>
<TR><TD><TT>element</TT></TD><TD>Element</TD></TR>
<TR><TD><TT>integer</TT></TD><TD>Integer number</TD></TR>
<TR><TD><TT>opaque</TT></TD><TD>Opaque string</TD></TR>
<TR><TD><TT>real</TT></TD><TD>Real number</TD></TR>
<TR><TD><TT>text</TT></TD><TD>Text fragment</TD></TR>
</TABLE>
</DIV><HR NOSHADE>
<A HREF="index.html">Contents</A>
<A HREF="relnotes.html">Previous</A>
<A HREF="schema.html">Next</A>
</BODY>
</HTML>
